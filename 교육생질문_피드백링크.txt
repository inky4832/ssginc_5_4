# 쇼핑몰 구축 가이드
https://support.cafe24.com/hc/ko/articles/7668080790937-%EC%87%BC%ED%95%91%EB%AA%B0-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0

# 관리자 계정 인증 방식 
https://techdocs.broadcom.com/kr/ko/symantec-security-software/endpoint-security-and-management/endpoint-protection/all/managing-groups-clients-and-administrators/managing-administrator-accounts-v17364367-d1e6/choosing-the-authentication-method-for-administrat-v9542292-d1e613.html
https://support.eximbay.com/hc/ko/articles/19893888611737-%EA%B4%80%EB%A6%AC%EC%9E%90%ED%8E%98%EC%9D%B4%EC%A7%80-Admin-%EB%A1%9C%EA%B7%B8%EC%9D%B8-2%EC%B0%A8-%EC%9D%B8%EC%A6%9D-%EB%B0%A9%EB%B2%95%EC%9D%B4-%EA%B6%81%EA%B8%88%ED%95%A9%EB%8B%88%EB%8B%A4

//////////////////////////////////////////////////////////////////////////////////////

# AI 플랫폼
- 무료 AI 도구
 ## 구글
https://cloud.google.com/use-cases/free-ai-tools?hl=ko

 ## AWS
https://aws.amazon.com/ko/free/ai/

 ## naver
https://api-fin.ncloud-docs.com/docs/home

//////////////////////////////////////////////////////////////////////////////////////

# 케이스 분석 샘플
## 케이스 분석1 - SSG 
https://blog.naver.com/ameliejeong/223505593627

## 케이스 분석2 - 마켓컬리
https://blog.naver.com/ameliejeong/223496701695

## 케이스 분석3 - 쿠팡
https://blog.naver.com/ameliejeong/223488884290

//////////////////////////////////////////////////////////////////////////////////////
# QR코드 + Firebase 연동
## 안드로이드 - QR코드 스캔하여 Firebase Realtime Database에 저장
https://seopseop911.tistory.com/37

## Firebase & Spring-boot 연동
https://data-make.tistory.com/768

//////////////////////////////////////////////////////////////////////////////////////
# 결제연동 API 제공

## 부트페이
https://www.bootpay.co.kr/

## 카카오페이
https://developers.kakaopay.com/docs/getting-started/basic/developers-intro

## 토스
https://developers.tosspayments.com/

## 외부 API 결제 솔루션
https://portone.io/korea/ko
https://sdk-playground.portone.io/
https://github.com/iamport/rest-client-nodejs

////////////////////////////////////////////////////////////////////////////
# 엘라스틱 서치 ( Elasticsearch )
https://esbook.kimjmin.net/


/////////////////////////////////////////////////////////////////////////
# SpringSecurity 와 Oauth 2.0 개념
https://its-ward.tistory.com/entry/Spring-Security%EC%99%80Oauth-20-%EA%B0%9C%EB%85%90-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0

# react + daum 주소 API 사용
https://velog.io/@eunjios/react-daum-postcode-practice

# SpringBoot + Zxing 연동
https://lucas-owner.tistory.com/55

# axios + POST + JSON
https://britny-no.tistory.com/32


# http --> https 
https://ngrok.com/

만약 ngrok에서 6024 에러가 날때 해결 방법
        headers: {
          'Content-Type': `application/json`,
          'ngrok-skip-browser-warning': '69420',
        },
https://velog.io/@se2id/ngrok-skip-browser-warning-ERRNGROK6024%EC%97%90%EB%9F%AC-Get%EC%9A%94%EC%B2%AD%EC%8B%9C-doctype-html-%EB%9C%B0-%EB%95%8C

# mybatis에서  underscore로 된 컬럼을  Camel로 된 자바변수로 자동 맵핑
mybatis.configuration.map-underscore-to-camel-case=true


# axios 
import axios from 'axios';

const apiClient = axios.create(
  {  
    baseURL:'https://reqres.in/'
  }
);

export async function axiosUsersList() {
  let resData;

    const response = await apiClient.get("/api/users?page=2");
    console.log(response)
    if (!response === 200) {
      console.log("fetchUsersList.ERROR")
      throw new Error('usersList 요청 예외');
    }
     resData = await response.data.data;

  return resData;
}

# 장바구니 
==> 장바구니와 장바구니 아이템을 분리해서 구현

public class BasketDTO{

     String basketId;
     String userId;
     ..
     List<BasketItemDTO> items;

    class BasketItemDTO{

         String productId;
         String productName;
         ...

    }
}

# Chart 그리기
https://echarts.apache.org/examples/en/index.html#chart-type-radar


# 리액트 상태관리
https://zustand-demo.pmnd.rs/
https://recoiljs.org/ko/

### 상태관리 라이브러리 기준

- **커뮤니티 크기** : Redux > MobX > Recoil = Zustand > Context API
- **러닝커브** : Redux > MobX > Recoil > Zustand > Context API
- **프로젝트 크기**
    - 큰 프로젝트 : Redux = MobX > Recoil > Zustand = Context API
    - 중간 프로젝트 : MobX > Recoil = Zustand > Redux > Context API
    - 작은 프로젝트 : Zustand > Recoil > MobX > Redux > Context API
- **설치 및 설정 간편성** : Zustand > Recoil > Context API > MobX > Redux
- **배우기 쉬운 정도** : Zustand > Recoil = Context API > MobX > Redux
- **미들웨어 및 고급 기능 지원** : Redux > MobX > Recoil > Zustand = Context API
- **중첩된 객체 또는 복잡한 상태 구조 관리** : MobX > Recoil > Redux = Zustand > Context API
- **함수형 및 클래스형 컴포넌트 모두 지원** : MobX > Recoil > Zustand > Context API > Redux
- **동기 및 비동기 업데이트 지원** : Recoil > Zustand > Redux > MobX > Context API
- **성능** : Recoil > Zustand > MobX > Redux > Context API
- **비동기 처리 지원** : Recoil > Zustand > Redux > MobX > Context API
- **기존 프로젝트와의 호환성** : Redux > MobX > Zustand > Recoil > Context API


# 웹소켓 vs SSE 
WebSocket :  서버와 클라이언트 간에 Socket Connection을 유지해서 언제든 양방향 통신 또는 데이터 전송이 가능하도록 하는 기술
SSE : Server-Sent-Event의 약자로, 서버에서 클라이언트로 실시간 이벤트를 전달하는 웹 기술
웹소켓과 sse 의 큰 차이점은 웹소켓은 양방향이지만 sse 는 단방향이다

## SSE

장점

1. HTTP 를 통해 통신하므로 다른 프로토콜은 필요없고, 구현이 쉽다
2. 네트워크 연결이 끊겼을때 자동으로 재연결
3. 실시간으로 서버에서 클라이언트로 데이터 전송가능

단점

1. GET 메소드만 지원하고, 파라미터를 보내는데 한계가 있다
2. 단방향 통신이며, 한 번 보내면 취소가 불가능하다는 단점
3. 클라이언트가 페이지닫으면, 서버에서 감지하기 어려움

SSE의 실행 과정 

1. 클라이언트가 서버의 이벤트를 구독하기 위한 요청을 보냄
2. 서버에서는 클라이언트와 매핑되는 SSE 객체를 만듬
3. 서버는 이벤트 스트림을 생성하고, 클라이언트에 비동기적으로 데이터 전송

프론트에서 sse 를 이용하여 서버에서 받기
useEffect(() => {
    if (!window.EventSource) {
      console.error('해당 환경에서 지원이 불가능 합니다')
      return
    }

    // 초기연결
    const eventSource = new EventSource(
      'http://10.10.10.195:8090/hello',
    )
    // 연결되었을때
    eventSource.onopen = () => {
      console.log('connection opened')
    }
    // 메세지 받았을 때
    eventSource.onmessage = (event) => {
      const data = event.data
      const parsedData = data.split(':')
      console.log(parsedData)

      setPrice(parsedData[2])
    }

    // 에러 발생시
    eventSource.onerror = (error) => {
      console.error('EventSource failed:', error)
      eventSource.close()
    }

    console.log(price)
  }, [])
